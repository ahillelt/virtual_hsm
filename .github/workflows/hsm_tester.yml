name: Standalone Tools - Test and Cross-Compile

on:
  push:
    branches:
      - main
      - 'claude/**'
  pull_request:
    branches: [ main ]
    
permissions:
  contents: write
  pull-requests: write
  
env:
  # SECURITY: Use GitHub Secrets for sensitive values in production
  # These are example values for CI/CD testing only - DO NOT use in production
  SECRETS_TEST: ${{ secrets.SECRETS_TEST || '0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef' }}
  ACTION_KEY: ${{ secrets.ACTION_KEY || '0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef' }}
  APP_SEC_KEY: ${{ secrets.APP_SEC_KEY || '9876543210fedcba9876543210fedcba0123456789abcdef0123456789abcdef' }}

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential libssl-dev

    - name: Build virtual_hsm
      run: |
        gcc -o virtual_hsm virtual_hsm.c -lcrypto -lssl -g -Wall -Wextra || {
          echo "Build failed!"
          exit 1
        }

    - name: Verify binary exists
      run: |
        if [ ! -f virtual_hsm ]; then
          echo "Error: virtual_hsm binary not found"
          exit 1
        fi
        chmod +x virtual_hsm

    - name: Create test directories
      run: |
        mkdir -p test_output

    - name: Test 1 - Generate master key
      run: |
        ./virtual_hsm -generate_master_key store_key
        if [ ! -f master.key ]; then
          echo "Error: master.key not generated"
          exit 1
        fi
        echo "✓ Master key generation successful"

    - name: Test 2 - Generate key pair
      run: |
        ./virtual_hsm -generate_key_pair test_key
        echo "✓ Key pair generation successful"

    - name: Test 3 - List keys
      run: |
        ./virtual_hsm -list
        echo "✓ List keys successful"

    - name: Test 4 - Sign and verify data
      run: |
        echo "Test data for signing" > test_output/test_data.txt
        ./virtual_hsm -sign test_key -i test_output/test_data.txt -o test_output/signature.bin
        if [ ! -f test_output/signature.bin ]; then
          echo "Error: signature.bin not created"
          exit 1
        fi
        echo "✓ Signing successful"

        ./virtual_hsm -verify test_key -i test_output/test_data.txt -s test_output/signature.bin
        echo "✓ Verification successful"

    - name: Test 5 - Export and import public key
      run: |
        ./virtual_hsm -export_public_key test_key > test_output/public_key.pem
        if [ ! -f test_output/public_key.pem ]; then
          echo "Error: public_key.pem not created"
          exit 1
        fi
        echo "✓ Export public key successful"

        ./virtual_hsm -import_public_key imported_key -i test_output/public_key.pem
        echo "✓ Import public key successful"

    - name: Test 6 - Store and retrieve symmetric key
      run: |
        echo -n "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef" | ./virtual_hsm -store sym_key
        ./virtual_hsm -retrieve sym_key > test_output/retrieved_key.txt
        if [ ! -f test_output/retrieved_key.txt ]; then
          echo "Error: retrieved_key.txt not created"
          exit 1
        fi
        echo "✓ Store and retrieve symmetric key successful"

    - name: All tests passed
      run: |
        echo "========================================="
        echo "All virtual_hsm tests passed successfully!"
        echo "========================================="

  enhanced-features-test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential libssl-dev libfido2-dev libjson-c-dev

    - name: Build enhanced HSM
      run: |
        gcc -o hsm_enhanced hsm_enhanced.c -lcrypto -lssl -g -Wall -Wextra || {
          echo "Enhanced HSM build failed!"
          exit 1
        }
        chmod +x hsm_enhanced

    - name: Build passkey tool
      run: |
        gcc -o passkey_tool passkey.c -lfido2 -ljson-c -lcrypto -g -Wall -Wextra || {
          echo "Passkey tool build failed!"
          exit 1
        }
        chmod +x passkey_tool
        echo "✓ Passkey tool built successfully"

    - name: Test hardware scan
      run: |
        ./hsm_enhanced -scan_hardware | grep "Scanning for HSM Hardware"
        echo "✓ Hardware scan works"

    - name: Test master key with audit log
      run: |
        ./hsm_enhanced -generate_master_key store_key
        test -f master.key || exit 1
        test -f hsm_audit.log || exit 1
        echo "✓ Master key and audit log created"

    - name: Test key with metadata
      run: |
        echo -n "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef" | ./hsm_enhanced -store test_key1
        test -f .test_key1.metadata || exit 1
        echo "✓ Key stored with lifecycle metadata"

    - name: Test signing with audit
      run: |
        ./hsm_enhanced -generate_key_pair signing_key
        echo "Test data" > test_data.txt
        ./hsm_enhanced -sign signing_key -i test_data.txt -o signature.bin
        test -f signature.bin || exit 1
        test $(wc -c < signature.bin) -eq 64 || exit 1
        ./hsm_enhanced -verify signing_key -i test_data.txt -s signature.bin
        echo "✓ Signing and verification with audit"

    - name: Verify audit log
      run: |
        # Audit log is encrypted - use the -audit_logs command to read it
        ./hsm_enhanced -audit_logs 365 > audit_output.txt
        grep "KEY_CREATED" audit_output.txt || exit 1
        grep "SIGN_OPERATION" audit_output.txt || exit 1
        echo "✓ Audit log contains expected entries"

    - name: Test enhanced commands
      run: |
        # Test set_user command
        ./hsm_enhanced -set_user "test_user@example.com" | grep "User ID set"
        echo "✓ Set user command works"

        # Test key_info command
        ./hsm_enhanced -key_info test_key1 | grep "Key Information"
        echo "✓ Key info command works"

        # Test audit_logs command
        ./hsm_enhanced -audit_logs 1 | grep "Audit Log"
        echo "✓ Audit logs command works"

        # Test rotate_key command
        echo -n "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef" | ./hsm_enhanced -store rotate_test_key
        ./hsm_enhanced -rotate_key rotate_test_key
        ./hsm_enhanced -key_info rotate_test_key | grep "Rotation Version: 2"
        echo "✓ Key rotation command works"

    - name: Test file signing and verification
      run: |
        # Create a test file with random content
        dd if=/dev/urandom of=test_document.bin bs=1024 count=10 2>/dev/null
        echo "Created random test file (10KB)"

        # Calculate and display file hash for verification
        sha256sum test_document.bin

        # Generate signing key pair
        ./hsm_enhanced -generate_key_pair file_signer
        test -f keystore.dat || exit 1
        echo "✓ Signing key pair generated"

        # Sign the file
        ./hsm_enhanced -sign file_signer -i test_document.bin -o test_document.sig
        test -f test_document.sig || exit 1
        test $(wc -c < test_document.sig) -eq 64 || exit 1
        echo "✓ File signed successfully (64-byte ED25519 signature)"

        # Verify the signature
        ./hsm_enhanced -verify file_signer -i test_document.bin -s test_document.sig
        echo "✓ File signature verified successfully"

        # Create a second test file to ensure signing produces different signatures
        dd if=/dev/urandom of=test_document2.bin bs=1024 count=10 2>/dev/null
        ./hsm_enhanced -sign file_signer -i test_document2.bin -o test_document2.sig

        # Verify signatures are different for different files
        if ! cmp -s test_document.sig test_document2.sig; then
          echo "✓ Different files produce different signatures"
        else
          echo "✗ Warning: Identical signatures for different files!"
        fi

        # Clean up test files
        rm -f test_document.bin test_document.sig test_document2.bin test_document2.sig
        echo "✓ File signing and verification test completed"

    - name: Enhanced features test summary
      run: |
        echo "========================================="
        echo "Enhanced features tested successfully!"
        echo "========================================="
        echo "✓ Hardware scanning"
        echo "✓ Audit logging"
        echo "✓ Key lifecycle metadata"
        echo "✓ Enhanced signing/verification"
        echo "✓ Enhanced commands (set_user, key_info, audit_logs, rotate_key)"
        echo "✓ File signing and verification (10KB random file)"
        echo "✓ Passkey tool compilation"

  cross-compile:
    needs: build-and-test
    runs-on: ubuntu-latest
    strategy:
      matrix:
        target: [linux-x86_64, windows-x86, windows-x86_64]
        include:
          - target: linux-x86_64
            cc: gcc
            output: virtual_hsm_linux_x86_64
            defines: ""
          - target: windows-x86
            cc: i686-w64-mingw32-gcc
            output: virtual_hsm_windows_x86.exe
            defines: "-DWIN32_LEAN_AND_MEAN -D_WIN32"
          - target: windows-x86_64
            cc: x86_64-w64-mingw32-gcc
            output: virtual_hsm_windows_x86_64.exe
            defines: "-DWIN32_LEAN_AND_MEAN -D_WIN32"
    steps:
      - uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential mingw-w64 libssl-dev zip

      - name: Build static OpenSSL for Windows
        if: contains(matrix.target, 'windows')
        run: |
          # Download and extract OpenSSL source
          wget https://www.openssl.org/source/openssl-3.1.4.tar.gz
          tar xzf openssl-3.1.4.tar.gz
          cd openssl-3.1.4
      
          if [ "${{ matrix.target }}" = "windows-x86" ]; then
            TARGET_DIR="$PWD/../openssl_static_x86"
            CROSS_PREFIX="i686-w64-mingw32-"
            CONFIG_TARGET="mingw"
          else
            TARGET_DIR="$PWD/../openssl_static_x64"
            CROSS_PREFIX="x86_64-w64-mingw32-"
            CONFIG_TARGET="mingw64"
          fi
      
          mkdir -p ${TARGET_DIR}/{lib,include,bin}
      
          ./Configure ${CONFIG_TARGET} no-shared \
            --prefix=${TARGET_DIR} \
            --openssldir=${TARGET_DIR}/ssl \
            --libdir=lib \
            --cross-compile-prefix=${CROSS_PREFIX} \
            -static || {
              echo "Configure failed!"
              cat config.log
              exit 1
          }
      
          make -j$(nproc) build_sw 2>&1 | tee make.log || {
            echo "Make failed!"
            echo "Last 50 lines of build output:"
            tail -n 50 make.log
            exit 1
          }
      
          make install_sw || {
            echo "Install failed!"
            exit 1
          }
          
          cd ..

      - name: Compile for ${{ matrix.target }}
        run: |
          # Create directories
          mkdir -p release_package
          mkdir -p release
          
          if [[ "${{ matrix.target }}" == windows-* ]]; then
            # Windows build configuration
            if [ "${{ matrix.target }}" = "windows-x86" ]; then
              OPENSSL_DIR="$PWD/openssl_static_x86"
            else
              OPENSSL_DIR="$PWD/openssl_static_x64"
            fi
            
            echo "OpenSSL directory contents:"
            ls -R ${OPENSSL_DIR}
            
            echo "Compiling with OpenSSL from: ${OPENSSL_DIR}"
            
            # Compile directly into release_package directory
            ${{ matrix.cc }} -o "release_package/${{ matrix.output }}" virtual_hsm.c \
              ${{ matrix.defines }} \
              -I. \
              -I${OPENSSL_DIR}/include \
              -L${OPENSSL_DIR}/lib \
              -static \
              -static-libgcc \
              -static-libstdc++ \
              -Wl,-Bstatic \
              ${OPENSSL_DIR}/lib/libssl.a \
              ${OPENSSL_DIR}/lib/libcrypto.a \
              -lws2_32 \
              -lgdi32 \
              -lcrypt32 \
              -luser32 \
              -ladvapi32 \
              -lkernel32 \
              -lbcrypt \
              -g -Wall -Wextra || {
                echo "Compilation failed!"
                exit 1
              }

            # Create Windows README
            echo "Virtual HSM Windows Build" > release_package/README.txt
            echo "------------------------" >> release_package/README.txt
            echo "" >> release_package/README.txt
            echo "This package contains the Virtual HSM executable built as a static binary." >> release_package/README.txt
            echo "No additional DLLs are required to run this application." >> release_package/README.txt
            
            # Create release archive
            (cd release_package && zip "../release/${{ matrix.output }}_release.zip" ./* ) || {
              echo "Failed to create release archive"
              exit 1
            }
            
          else
            # Linux compilation
            ${{ matrix.cc }} -o "release_package/${{ matrix.output }}" virtual_hsm.c \
              -static \
              -Wl,--no-export-dynamic \
              -Wl,-Bstatic \
              -lcrypto -lssl \
              -pthread \
              -Wl,--whole-archive -lpthread -Wl,--no-whole-archive \
              -ldl -lz \
              ${{ matrix.defines }} \
              -g -Wall -Wextra || {
                echo "Compilation failed!"
                exit 1
              }
            
            # Create release archive
            (cd release_package && tar czf "../release/${{ matrix.output }}_release.tar.gz" ./* ) || {
              echo "Failed to create release archive"
              exit 1
            }
          fi
          
          # Verify files exist
          if [ ! -f "release_package/${{ matrix.output }}" ]; then
            echo "Error: Binary not found in release_package"
            exit 1
          fi
          
          if [[ "${{ matrix.target }}" == windows-* ]]; then
            if [ ! -f "release/${{ matrix.output }}_release.zip" ]; then
              echo "Error: Release archive not found"
              exit 1
            fi
          else
            if [ ! -f "release/${{ matrix.output }}_release.tar.gz" ]; then
              echo "Error: Release archive not found"
              exit 1
            fi
          fi
          
          # Debug output
          echo "Contents of release_package directory:"
          ls -la release_package/
          echo "Contents of release directory:"
          ls -la release/

      - name: Commit to main branch
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          git fetch origin main
          git checkout main
          
          if [ -f "release_package/${{ matrix.output }}" ]; then
            chmod +x "release_package/${{ matrix.output }}"
            git add -f "release_package/${{ matrix.output }}" || {
              echo "Failed to add binary"
              exit 1
            }
            
            if [[ "${{ matrix.target }}" == windows-* ]]; then
              git add -f "release/${{ matrix.output }}_release.zip" || {
                echo "Failed to add release zip"
                exit 1
              }
            else
              git add -f "release/${{ matrix.output }}_release.tar.gz" || {
                echo "Failed to add release tar.gz"
                exit 1
              }
            fi
            
            git commit -m "Update binary and release artifacts for ${{ matrix.target }}" || {
              echo "No changes to commit"
              exit 0
            }
            
            git pull --rebase origin main
            git push origin main
          else
            echo "Error: Binary not found for commit"
            exit 1
          fi

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.output }}_all_artifacts
          path: |
            ./release_package/${{ matrix.output }}
            ./release/${{ matrix.output }}_release.*
          if-no-files-found: error
