name: Virtual HSM Test and Cross-Compilation

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  SECRETS_TEST: "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
  ACTION_KEY: "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
  APP_SEC_KEY: "9876543210fedcba9876543210fedcba0123456789abcdef0123456789abcdef"

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y libssl-dev

    - name: Compile program
      run: gcc -o virtual_hsm virtual_hsm.c -lcrypto -lssl -g -Wall -Wextra

    - name: Store keys using SECRETS_TEST
      run: |
        echo "Storing ActionKey with value: ${{ env.ACTION_KEY }}"
        echo -n "${{ env.ACTION_KEY }}" | xxd -p  # Debug: show hex of input
        echo -n "${{ env.ACTION_KEY }}" | ./virtual_hsm -master_key ${{ env.SECRETS_TEST }} -keystore test.keystore.dat -store ActionKey
        echo "ActionKey stored"
        
        echo "Storing APP_SEC_KEY with value: ${{ env.APP_SEC_KEY }}"
        echo -n "${{ env.APP_SEC_KEY }}" | xxd -p  # Debug: show hex of input
        echo -n "${{ env.APP_SEC_KEY }}" | ./virtual_hsm -master_key ${{ env.SECRETS_TEST }} -keystore test.keystore.dat -store myappseckey
        echo "APP_SEC_KEY stored"
        
        echo "Keystore contents:"
        hexdump -C test.keystore.dat

    - name: List keys
      run: |
        ./virtual_hsm -master_key ${{ env.SECRETS_TEST }} -keystore test.keystore.dat -list

    - name: Retrieve and verify keys
      run: |
        echo "Retrieving ActionKey:"
        retrieved=$(./virtual_hsm -master_key ${{ env.SECRETS_TEST }} -keystore test.keystore.dat -retrieve ActionKey)
        retrieved=$(echo "$retrieved" | tr -d '\n' | tr -d ' ')  # Remove newlines and spaces
        expected="${{ env.ACTION_KEY }}"
        echo "Retrieved value (hex): $retrieved"
        echo "Expected value (hex): $expected"
        if [ "$retrieved" != "$expected" ]; then
          echo "Error: Retrieved ActionKey does not match stored value"
          echo "Expected: $expected"
          echo "Actual  : $retrieved"
          echo "Lengths - Expected: ${#expected}, Actual: ${#retrieved}"
          exit 1
        fi

        echo "Retrieving myappseckey:"
        retrieved=$(./virtual_hsm -master_key ${{ env.SECRETS_TEST }} -keystore test.keystore.dat -retrieve myappseckey)
        retrieved=$(echo "$retrieved" | tr -d '\n' | tr -d ' ')  # Remove newlines and spaces
        expected="${{ env.APP_SEC_KEY }}"
        echo "Retrieved value (hex): $retrieved"
        echo "Expected value (hex): $expected"
        if [ "$retrieved" != "$expected" ]; then
          echo "Error: Retrieved myappseckey does not match stored value"
          echo "Expected: $expected"
          echo "Actual  : $retrieved"
          echo "Lengths - Expected: ${#expected}, Actual: ${#retrieved}"
          exit 1
        fi

    - name: Test digital signature functionality
      run: |
        echo "Generating key pair..."
        ./virtual_hsm -master_key ${{ env.SECRETS_TEST }} -keystore test.keystore.dat -generate_key_pair test_key_pair

        echo "Signing data..."
        echo -n "Test data to sign" | ./virtual_hsm -master_key ${{ env.SECRETS_TEST }} -keystore test.keystore.dat -sign test_key_pair > signature.bin
        
        echo "Signature contents:"
        xxd signature.bin

        echo "Verifying signature..."
        (echo -n "Test data to sign"; cat signature.bin) | ./virtual_hsm -master_key ${{ env.SECRETS_TEST }} -keystore test.keystore.dat -verify test_key_pair

        echo "Exporting public key..."
        ./virtual_hsm -master_key ${{ env.SECRETS_TEST }} -keystore test.keystore.dat -export_public_key test_key_pair > public_key_test.pem
        
        echo "Public key contents:"
        cat public_key_test.pem

        echo "Importing public key..."
        cat public_key_test.pem | ./virtual_hsm -master_key ${{ env.SECRETS_TEST }} -keystore test.keystore.dat -import_public_key imported_public_key

        echo "Verifying signature with imported public key..."
        (echo -n "Test data to sign"; cat signature.bin) | ./virtual_hsm -master_key ${{ env.SECRETS_TEST }} -keystore test.keystore.dat -verify imported_public_key

    - name: Cleanup
      run: |
        rm -f test.keystore.dat signature.bin public_key.pem
        export SECRETS_TEST=""
        export ACTION_KEY=""
        export APP_SEC_KEY=""

  cross-compile:
    needs: build-and-test
    runs-on: ubuntu-latest
    strategy:
      matrix:
        target: [linux-x86_64, windows-x86, windows-x86_64]
        include:
          - target: linux-x86_64
            cc: gcc
            output: virtual_hsm_linux_x86_64
            defines: ""
          - target: windows-x86
            cc: i686-w64-mingw32-gcc
            output: virtual_hsm_windows_x86.exe
            defines: "-DWIN32_LEAN_AND_MEAN -D_WIN32"
          - target: windows-x86_64
            cc: x86_64-w64-mingw32-gcc
            output: virtual_hsm_windows_x86_64.exe
            defines: "-DWIN32_LEAN_AND_MEAN -D_WIN32"
    steps:
      - uses: actions/checkout@v4

      - name: Install dependencies 
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential mingw-w64 libssl-dev

      - name: Install Windows OpenSSL dependencies
        if: contains(matrix.target, 'windows')
        run: |
          mkdir openssl_setup
          cd openssl_setup

          wget https://download.firedaemon.com/FireDaemon-OpenSSL/openssl-3.4.0.zip
          unzip openssl-3.4.0.zip

          if [ "${{ matrix.target }}" = "windows-x86" ]; then
            MINGW_PATH="/usr/i686-w64-mingw32"
            OPENSSL_ARCH="x86"
          else
            MINGW_PATH="/usr/x86_64-w64-mingw32"
            OPENSSL_ARCH="x64"
          fi

          sudo mkdir -p $MINGW_PATH/{include/openssl,lib,bin}
          sudo cp -r ./$OPENSSL_ARCH/include/openssl/* $MINGW_PATH/include/openssl/
          sudo cp ./$OPENSSL_ARCH/lib/*.lib $MINGW_PATH/lib/
          sudo cp ./$OPENSSL_ARCH/bin/*.dll $MINGW_PATH/bin/
          
          cd ..
          rm -rf openssl_setup

      - name: Create Windows compatibility header
        if: contains(matrix.target, 'windows')
        run: |
          cat > win32_compat.h << "EOL"
          #ifdef _WIN32
          #include <winsock2.h>
          #include <windows.h>
          #include <ws2tcpip.h>
          #else
          #include <sys/select.h>
          #endif
          EOL

      - name: Compile for ${{ matrix.target }}
        run: |
          mkdir -p release_package
          
          if [[ "${{ matrix.target }}" == windows-* ]]; then
            # Windows build configuration
            if [ "${{ matrix.target }}" = "windows-x86" ]; then
              MINGW_PATH="/usr/i686-w64-mingw32"
              DLL_SUFFIX=""
            else
              MINGW_PATH="/usr/x86_64-w64-mingw32"
              DLL_SUFFIX="-x64"
            fi
            
            ${{ matrix.cc }} -o ${{ matrix.output }} virtual_hsm.c \
              ${{ matrix.defines }} \
              -I. \
              -I$MINGW_PATH/include \
              -L$MINGW_PATH/lib \
              -L$MINGW_PATH/bin \
              -lcrypto \
              -lssl \
              -lws2_32 \
              -lgdi32 \
              -lcrypt32 \
              -luser32 \
              -ladvapi32 \
              -lkernel32 \
              -lbcrypt \
              -g -Wall -Wextra

            cp ${{ matrix.output }} release_package/
            cp $MINGW_PATH/bin/libcrypto-3${DLL_SUFFIX}.dll release_package/
            cp $MINGW_PATH/bin/libssl-3${DLL_SUFFIX}.dll release_package/
            cp $MINGW_PATH/bin/libgcc_s_*-1.dll release_package/
            cp $MINGW_PATH/bin/libstdc++-6.dll release_package/
            cp $MINGW_PATH/bin/libwinpthread-1.dll release_package/

            # Create Windows README using multiple echo commands
            echo "Virtual HSM Windows Build" > release_package/README.txt
            echo "------------------------" >> release_package/README.txt
            echo "" >> release_package/README.txt
            echo "This package contains the Virtual HSM executable and all required DLLs." >> release_package/README.txt
            echo "Please keep all files in the same directory when running the application." >> release_package/README.txt
            echo "" >> release_package/README.txt
            echo "Files included:" >> release_package/README.txt
            echo "- ${{ matrix.output }}" >> release_package/README.txt
            echo "- libcrypto-3${DLL_SUFFIX}.dll" >> release_package/README.txt
            echo "- libssl-3${DLL_SUFFIX}.dll" >> release_package/README.txt
            echo "- Additional runtime DLLs required for operation" >> release_package/README.txt

          else
            # Linux build configuration
            ${{ matrix.cc }} -o ${{ matrix.output }} virtual_hsm.c \
              -static -static-libgcc -static-libstdc++ \
              -lcrypto -lssl \
              ${{ matrix.defines }} \
              -g -Wall -Wextra
            
            cp ${{ matrix.output }} release_package/
            
            # Create Linux README
            cat > "release_package/README.txt" << EOT
Virtual HSM Linux Build
----------------------

This package contains the Virtual HSM executable built as a static binary.
No additional runtime dependencies are required.

Files included:
- ${{ matrix.output }}
EOT
          fi

      - name: Verify binary and dependencies
        run: |
          if [ -f "release_package/${{ matrix.output }}" ]; then
            echo "Binary exists. Checking properties:"
            file release_package/${{ matrix.output }}
            if [[ "${{ matrix.target }}" == windows-* ]]; then
              echo "Windows binary dependencies:"
              ${{ matrix.cc }}-objdump -p release_package/${{ matrix.output }} | grep "DLL"
              echo "Package contents:"
              ls -l release_package/
            else
              echo "Linux binary dependencies:"
              ldd release_package/${{ matrix.output }} || echo "No shared library dependencies (static binary)"
            fi
            sha256sum release_package/${{ matrix.output }}
          else
            echo "Error: Binary not found!"
            exit 1
          fi

      - name: Create release archive
        run: |
          cd release_package
          if [[ "${{ matrix.target }}" == windows-* ]]; then
            zip -r ../${{ matrix.output }}_release.zip *
          else
            tar czf ../${{ matrix.output }}_release.tar.gz *
          fi

      - name: Upload release package
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.output }}_release_package
          path: release_package/*
          if-no-files-found: error

      - name: Upload release archive
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.output }}_release_archive
          path: |
            ${{ matrix.output }}_release.zip
            ${{ matrix.output }}_release.tar.gz
          if-no-files-found: warn
