name: Virtual HSM Test
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  SECRETS_TEST: "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
  ACTION_KEY: "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
  APP_SEC_KEY: "9876543210fedcba9876543210fedcba0123456789abcdef0123456789abcdef"

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y libssl-dev

    - name: Compile program
      run: gcc -o virtual_hsm virtual_hsm.c -lcrypto -lssl -g -Wall -Wextra

    - name: Store keys using SECRETS_TEST
      run: |
        echo "Storing ActionKey with value: ${{ env.ACTION_KEY }}"
        echo -n "${{ env.ACTION_KEY }}" | xxd -p  # Debug: show hex of input
        echo -n "${{ env.ACTION_KEY }}" | ./virtual_hsm -master_key ${{ env.SECRETS_TEST }} -keystore test.keystore.dat -store ActionKey
        echo "ActionKey stored"
        
        echo "Storing APP_SEC_KEY with value: ${{ env.APP_SEC_KEY }}"
        echo -n "${{ env.APP_SEC_KEY }}" | xxd -p  # Debug: show hex of input
        echo -n "${{ env.APP_SEC_KEY }}" | ./virtual_hsm -master_key ${{ env.SECRETS_TEST }} -keystore test.keystore.dat -store myappseckey
        echo "APP_SEC_KEY stored"
        
        echo "Keystore contents:"
        hexdump -C test.keystore.dat

    - name: List keys
      run: |
        ./virtual_hsm -master_key ${{ env.SECRETS_TEST }} -keystore test.keystore.dat -list

    - name: Retrieve and verify keys
      run: |
        echo "Retrieving ActionKey:"
        retrieved=$(./virtual_hsm -master_key ${{ env.SECRETS_TEST }} -keystore test.keystore.dat -retrieve ActionKey)
        retrieved=$(echo "$retrieved" | tr -d '\n' | tr -d ' ')  # Remove newlines and spaces
        expected="${{ env.ACTION_KEY }}"
        echo "Retrieved value (hex): $retrieved"
        echo "Expected value (hex): $expected"
        if [ "$retrieved" != "$expected" ]; then
          echo "Error: Retrieved ActionKey does not match stored value"
          echo "Expected: $expected"
          echo "Actual  : $retrieved"
          echo "Lengths - Expected: ${#expected}, Actual: ${#retrieved}"
          exit 1
        fi

        echo "Retrieving myappseckey:"
        retrieved=$(./virtual_hsm -master_key ${{ env.SECRETS_TEST }} -keystore test.keystore.dat -retrieve myappseckey)
        retrieved=$(echo "$retrieved" | tr -d '\n' | tr -d ' ')  # Remove newlines and spaces
        expected="${{ env.APP_SEC_KEY }}"
        echo "Retrieved value (hex): $retrieved"
        echo "Expected value (hex): $expected"
        if [ "$retrieved" != "$expected" ]; then
          echo "Error: Retrieved myappseckey does not match stored value"
          echo "Expected: $expected"
          echo "Actual  : $retrieved"
          echo "Lengths - Expected: ${#expected}, Actual: ${#retrieved}"
          exit 1
        fi

    - name: Test digital signature functionality
      run: |
        echo "Generating key pair..."
        ./virtual_hsm -master_key ${{ env.SECRETS_TEST }} -keystore test.keystore.dat -generate_key_pair test_key_pair

        echo "Signing data..."
        echo -n "Test data to sign" | ./virtual_hsm -master_key ${{ env.SECRETS_TEST }} -keystore test.keystore.dat -sign test_key_pair > signature.bin
        
        echo "Signature contents:"
        xxd signature.bin

        echo "Verifying signature..."
        (echo -n "Test data to sign"; cat signature.bin) | ./virtual_hsm -master_key ${{ env.SECRETS_TEST }} -keystore test.keystore.dat -verify test_key_pair

        echo "Exporting public key..."
        ./virtual_hsm -master_key ${{ env.SECRETS_TEST }} -keystore test.keystore.dat -export_public_key test_key_pair > public_key_test.pem
        
        echo "Public key contents:"
        cat public_key_test.pem

        echo "Importing public key..."
        cat public_key_test.pem | ./virtual_hsm -master_key ${{ env.SECRETS_TEST }} -keystore test.keystore.dat -import_public_key imported_public_key

        echo "Verifying signature with imported public key..."
        (echo -n "Test data to sign"; cat signature.bin) | ./virtual_hsm -master_key ${{ env.SECRETS_TEST }} -keystore test.keystore.dat -verify imported_public_key

    - name: Cleanup
      run: |
        rm -f test.keystore.dat signature.bin public_key.pem
        export SECRETS_TEST=""
        export ACTION_KEY=""
        export APP_SEC_KEY=""

    
  compile-versions:
    needs: build-and-test  # This ensures the job runs only if 'build-and-test' succeeds
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    # Step 1: Install tools and compile for Windows i86/x64 and Linux i86/x64
    - name: Install x86/x64 dependencies
      run: sudo apt-get install -y gcc-multilib g++-multilib

    - name: Compile for Windows i86/x64
      run: gcc -o virtual_hsm_win_i86 virtual_hsm.c -lcrypto -lssl -m64 -g -Wall -Wextra

    - name: Compile for Linux i86/x64
      run: gcc -o virtual_hsm_linux_i86 virtual_hsm.c -lcrypto -lssl -m64 -g -Wall -Wextra

    # Step 2: Install tools and compile for Linux ARM
    - name: Add ARM64 architecture
      run: |
        sudo dpkg --add-architecture arm64
        sudo apt-get update
   
    - name: Install ARM dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y gcc-aarch64-linux-gnu g++-aarch64-linux-gnu
        sudo apt-get install -y libssl-dev:arm64       

    - name: Compile for Linux ARM
      run: aarch64-linux-gnu-gcc -o virtual_hsm_linux_arm virtual_hsm.c -lcrypto -lssl -g -Wall -Wextra

    # Step 3: Compile for MacOS ARM and MacOS i86/x64
    - name: Install LLVM and Clang
      run: sudo apt-get install -y llvm clang

    - name: Compile for MacOS ARM
      run: clang -target arm64-apple-macos11 -o virtual_hsm_mac_arm virtual_hsm.c -lcrypto -lssl -g -Wall -Wextra

    - name: Compile for MacOS i86/x64
      run: clang -target x86_64-apple-macos10.12 -o virtual_hsm_mac_i86 virtual_hsm.c -lcrypto -lssl -g -Wall -Wextra

    - name: Upload compiled binaries
      uses: actions/upload-artifact@v3
      with:
        name: compiled_virtual_hsm
        path: |
          virtual_hsm_win_i86
          virtual_hsm_linux_i86
          virtual_hsm_linux_arm
          virtual_hsm_mac_arm
          virtual_hsm_mac_i86

